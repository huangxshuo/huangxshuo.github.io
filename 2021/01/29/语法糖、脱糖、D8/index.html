<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"huangxshuo.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="语法糖（Syntactic），也称语法糖衣，指在计算机语言中添加的某种语法，这种语法对语言的功能没有影响，但更方便程序员使用。简而言之，语法糖然程序更加简洁，有更高的可读性">
<meta property="og:type" content="article">
<meta property="og:title" content="语法糖、脱糖、D8">
<meta property="og:url" content="https://huangxshuo.github.io/2021/01/29/%E8%AF%AD%E6%B3%95%E7%B3%96%E3%80%81%E8%84%B1%E7%B3%96%E3%80%81D8/index.html">
<meta property="og:site_name" content="huangxiushuo">
<meta property="og:description" content="语法糖（Syntactic），也称语法糖衣，指在计算机语言中添加的某种语法，这种语法对语言的功能没有影响，但更方便程序员使用。简而言之，语法糖然程序更加简洁，有更高的可读性">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-01-29T04:12:57.000Z">
<meta property="article:modified_time" content="2021-03-03T02:27:09.062Z">
<meta property="article:author" content="huangxiushuo">
<meta property="article:tag" content="Lambda">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://huangxshuo.github.io/2021/01/29/%E8%AF%AD%E6%B3%95%E7%B3%96%E3%80%81%E8%84%B1%E7%B3%96%E3%80%81D8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>语法糖、脱糖、D8 | huangxiushuo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">huangxiushuo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">道阻且长，行则将至</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://huangxshuo.github.io/2021/01/29/%E8%AF%AD%E6%B3%95%E7%B3%96%E3%80%81%E8%84%B1%E7%B3%96%E3%80%81D8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="huangxiushuo">
      <meta itemprop="description" content="上海">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="huangxiushuo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          语法糖、脱糖、D8
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-29 12:12:57" itemprop="dateCreated datePublished" datetime="2021-01-29T12:12:57+08:00">2021-01-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-03 10:27:09" itemprop="dateModified" datetime="2021-03-03T10:27:09+08:00">2021-03-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2021/01/29/%E8%AF%AD%E6%B3%95%E7%B3%96%E3%80%81%E8%84%B1%E7%B3%96%E3%80%81D8/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/01/29/语法糖、脱糖、D8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
            <div class="post-description">语法糖（Syntactic），也称语法糖衣，指在计算机语言中添加的某种语法，这种语法对语言的功能没有影响，但更方便程序员使用。简而言之，语法糖然程序更加简洁，有更高的可读性</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h3><ul>
<li> 语法糖（Syntactic），也称语法糖衣，指在计算机语言中添加的某种语法，这种语法对语言的功能没有影响，但更方便程序员使用。简而言之，语法糖然程序更加简洁，有更高的可读性。</li>
<li> Java中最常用的语法糖主要有<strong>泛型</strong>、<strong>变长参数</strong>、<strong>条件编译</strong>、<strong>自动拆装箱</strong>、<strong>内部类</strong>等。  </li>
</ul>
<h3 id="解语法糖（脱糖）"><a href="#解语法糖（脱糖）" class="headerlink" title="解语法糖（脱糖）"></a>解语法糖（脱糖）</h3><p>语法糖的存在主要是方便开发人员使用，但JVM并不支持这些语法糖。因此这些<strong>语法糖在编译阶段就会被还原成简单的基础语法结构</strong>，这个过程就是解语法糖。  </p>
<h3 id="Java匿名内部类和转写成Lambda，字节码上的区别"><a href="#Java匿名内部类和转写成Lambda，字节码上的区别" class="headerlink" title="Java匿名内部类和转写成Lambda，字节码上的区别"></a>Java匿名内部类和转写成Lambda，字节码上的区别</h3><pre><code>//Lambda写法
class LambdaTest &#123;
    public static void main(String[] args) &#123;
        Runnable r = () -&gt; &#123;
            System.out.println(&quot;hello, lambda&quot;);
        &#125;;
        r.run();
    &#125;
&#125;  


//匿名内部类写法    
class LambdaTest2 &#123;
    public static void main(String[] args) &#123;
        Runnable r = new Runnable() &#123;
            @Override
            public void run() &#123;
                System.out.println(&quot;hello lambda&quot;);
            &#125;
        &#125;;
        r.run();
    &#125;
&#125;  
</code></pre>
<ul>
<li>匿名内部类写法在编译后会而外生成<code>LambdaTest2$1.class</code>类：</li>
</ul>
<pre><code>&#123;
  lambda.LambdaTest2();
    descriptor: ()V
    flags:
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V
         4: return
      LineNumberTable:
        line 8: 0

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=2, args_size=1
         0: new           #2                  // class lambda/LambdaTest2$1
         3: dup
         4: invokespecial #3                  // Method lambda/LambdaTest2$1.&quot;&lt;init&gt;&quot;:()V
         7: astore_1
         8: aload_1
         9: invokeinterface #4,  1            // InterfaceMethod java/lang/Runnable.run:()V
        14: return
      LineNumberTable:
        line 11: 0
        line 17: 8
        line 18: 14
&#125;  
</code></pre>
<ul>
<li>Lambda写法在编译后并没有生成额外的类： </li>
</ul>
<pre><code>&#123;
  lambda.LambdaTest();
    descriptor: ()V
    flags:
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V
         4: return
      LineNumberTable:
        line 8: 0

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=1, locals=2, args_size=1
         0: invokedynamic #2,  0              // InvokeDynamic #0:run:()Ljava/lang/Runnable;
         5: astore_1
         6: aload_1
         7: invokeinterface #3,  1            // InterfaceMethod java/lang/Runnable.run:()V
        12: return
      LineNumberTable:
        line 10: 0
        line 13: 6
        line 14: 12
&#125;  
</code></pre>
<p>​<br>在<code>invokedynamic</code>执行完之后，存储栈顶值，入栈。然后调用接口<code>Runnable</code>的<code>run()</code>方法。<br>这里的<strong>InvokeDynamic #0</strong>后面的#0对应的并不是常量池里的索引，而是一个叫<code>BootstrapMethods</code>的:</p>
<pre><code>0: #20 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;
    Method arguments:
      #21 ()V
      #22 invokestatic lambda/LambdaTest.lambda$main$0:()V
      #21 ()V
</code></pre>
<p>也就是0:后面的内容，可以看出它是通过<code>invokedynamic</code>来调用<code>LambdaMetafactory</code>的<code>metafactory</code>方法。断点可知：  </p>
<pre><code>    public static CallSite metafactory(MethodHandles.Lookup caller,     //caller: &quot;lambda.LambdaTest&quot;
                                       String invokedName,      //invokedName: &quot;run&quot;
                                       MethodType invokedType,      //invokedType: &quot;()Runnable&quot;      
                                       MethodType samMethodType,    //samMethodType: &quot;()void&quot;
                                       MethodHandle implMethod,     //implMethod: &quot;MethodHandle()void&quot;
                                       MethodType instantiatedMethodType)   //instantiatedMethodType: &quot;()void&quot;
            throws LambdaConversionException &#123;
        AbstractValidatingLambdaMetafactory mf;
        mf = new InnerClassLambdaMetafactory(caller, invokedType,
                                             invokedName, samMethodType,
                                             implMethod, instantiatedMethodType,
                                             false, EMPTY_CLASS_ARRAY, EMPTY_MT_ARRAY);
        mf.validateMetafactoryArgs();
        return mf.buildCallSite();
    &#125;
</code></pre>
<blockquote>
<p> <strong>invokedynamic</strong><br>    JVM字节码指令集一直比较稳定，一直到JAVA7中才增加了一个<code>invokedynamic</code>指令，这是JAVA为了实现<strong>动态类型语言</strong>支持而做的一种改进。但是在JAVA7中并没有提供直接生成<code>invokedynamic</code>指令的方法，需要借助<strong>ASM</strong>这种底层字节码工具来产生<code>invokedynamic</code>指令。直到JAVA8的Lambda表达式的出现，<code>invokedynamic</code>指令的生成，在java中才有了直接的生成方式。 </p>
</blockquote>
<p>invokedynamic指令所指定的bootstrap方法，编译器置入，java7中要自己提供一个这种静态方法，由asm工具写入字节码中，java8中jdk提供了这样的一个启动方法。JVM在类加载解析时，如果是invokedynamic时，每次都会进行重新解析，解析的时候，会首先执行bootstrap方法，LambdaMetafactory.metafactory方法的前三个参数，会在运行时根据访问类和运行期常量池动态传入，而后三个参数，则为bootstrap静态参数列表传入：</p>
<ol>
<li>泛型擦除后的方法签名及返回值；  </li>
<li>对应的匿名方法；</li>
<li>泛型擦除之前的方法签名及返回值  </li>
</ol>
<p>2调用的方法：<code>lambda$main$0:()</code>，而<code>LambdaTest</code>中并没有这个方法，猜测是编译器帮我们生成的，通过javap -p命令：  </p>
<pre><code>class lambda.LambdaTest &#123;
  lambda.LambdaTest();
  public static void main(java.lang.String[]);
  private static void lambda$main$0();
&#125;  
</code></pre>
<p>可以看到<code>LambdaTest</code>确实多了一个<code>lambda$main$0:()</code>方法。反射调用这个方法：</p>
<pre><code>class LambdaTest &#123;
    public static void main(String[] args) throws Exception&#123;
        Runnable r = () -&gt; &#123;
            System.out.println(&quot;hello, lambda&quot;);
        &#125;;
        r.run();
        LambdaTest.class.getDeclaredMethod(&quot;lambda$main$0&quot;).invoke(null);
    &#125;
&#125;  
</code></pre>
<p>“hello lambda”多打印了一次，查看其字节码： </p>
<pre><code> private static synthetic lambda$main$0()V
   L0
    LINENUMBER 11 L0
    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;
    LDC &quot;hello, lambda&quot;
    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V
   L1
    LINENUMBER 12 L1
    RETURN
    MAXSTACK = 2
    MAXLOCALS = 0  
</code></pre>
<p>对比<code>LambdaTest2</code>run()方法的字节码：  </p>
<pre><code>  public run()V
   L0
    LINENUMBER 14 L0
    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;
    LDC &quot;hello lambda&quot;
    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V
   L1
    LINENUMBER 15 L1
    RETURN
   L2
    LOCALVARIABLE this Llambda/LambdaTest2$1; L0 L2 0
    MAXSTACK = 2
    MAXLOCALS = 1
</code></pre>
<p>完全是一样的，获取静态变量<code>System.out</code>，<code>&quot;hello lambda&quot;</code>入栈，然后调用<code>PrintStream.println</code>方法。<br>那么这个<code>lambda$main$0()</code>是在哪里被调用的？两种方式：</p>
<ul>
<li><strong>抛异常打印堆栈信息</strong></li>
<li><strong>借鉴Class.forName的做法——通过Reflection的getCallerClass来获取到调用者的Class信息：</strong>  </li>
</ul>
<pre><code>public class LambdaTest &#123;
    public static void main(String[] args) throws Exception &#123;
        Runnable r = () -&gt; &#123;
            try &#123;
                Method getCallerClass = Class.forName(&quot;sun.reflect.Reflection&quot;).getDeclaredMethod(&quot;getCallerClass&quot;, int.class);
                int index = 0;
                Class&lt;?&gt; callerClass;
                while ((callerClass = (Class&lt;?&gt;) getCallerClass.invoke(null, index)) != null) &#123;
                    System.out.println(callerClass);
                    index++;
                &#125;
            &#125; catch (Exception e) &#123;
                e.printStackTrace();
            &#125;
        &#125;;
        r.run();
    &#125;
&#125;  
</code></pre>
<p> 运行后打印可知调用<code>lambda$main$0()</code>方法的是一个叫<code>lambda.LambdaTest$$Lambda$1/1531448569</code>的类<br>但我们在编译后并没有生成这个类，那可以推测它是JVM在运行时动态生成和加载的Runnable的实现类。打印Runnable实例的类名：</p>
<pre><code>System.out.println(String.format(&quot;Runnable Class: %s&quot;, r.getClass().getSimpleName()));
</code></pre>
<p>打印结果: </p>
<pre><code>hello, lambda
class sun.reflect.Reflection
class lambda.LambdaTest
class lambda.LambdaTest$$Lambda$1/1531448569
class lambda.LambdaTest
Runnable Class: LambdaTest$$Lambda$1/1531448569
</code></pre>
<ul>
<li>结论：Lambda表达式在编译后，其函数体都会放到CallerClass里一个额外生成的方法内（所谓的”匿名”函数），由JVM动态生成的实现类去调用。最终它也是通过内部类的方式实现的，只不过不像直接使用内部类那样在编译后生成额外的类，它把生成实现类这一步放到了运行时，由JVM完成。</li>
</ul>
<h3 id="Java中的Lambda与Android中的Lambda有什么不同？"><a href="#Java中的Lambda与Android中的Lambda有什么不同？" class="headerlink" title="Java中的Lambda与Android中的Lambda有什么不同？"></a>Java中的Lambda与Android中的Lambda有什么不同？</h3><pre><code>public class MainActivity extends AppCompatActivity &#123;

    @Override
    protected void onCreate(Bundle savedInstanceState) &#123;
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Runnable r = () -&gt; &#123;
            Log.d(&quot;MainActivity&quot;, &quot;hello lambda&quot;);
        &#125;;
        r.run();
    &#125;
&#125;
</code></pre>
<p>编译后打开dex：</p>
<pre><code>MainActivity
    &lt;linit&gt;()
    void lambda$onCreate$0()
    void onCreate(android.os.Bundle)
    void setContentView(int)
-$$Lambda$MainActivity$NKcUHI3kbmdlSYn5oJ5mHUINomA
    &lt;clinit&gt;()
    &lt;init&gt;()
    void run()
    com.hxs.androiddesugardemo.-$$Lambda$MainActivity$NKcUHI3kbmdlSYn5oJ5mHUINomA INSTANCE 
</code></pre>
<p>发现此时这个类已经存在dex里面了，同时<code>MainActivity</code>也多了一个<strong>lambda$onCreate$0</strong>方法。查看这个方法的字节码：</p>
<pre><code>.method static synthetic lambda$onCreate$0()V
    .registers 2

    .line 15
    const-string v0, &quot;MainActivity&quot;

    const-string v1, &quot;hello lambda&quot;

    invoke-static &#123;v0, v1&#125;, Landroid/util/Log;-&gt;d(Ljava/lang/String;Ljava/lang/String;)I

    .line 16
    new-instance v0, Ljava/lang/RuntimeException;

    invoke-direct &#123;v0&#125;, Ljava/lang/RuntimeException;-&gt;&lt;init&gt;()V

    throw v0
.end method
</code></pre>
<ol>
<li>先注册了2个寄存器；</li>
<li>把字符串常量 “Application” 赋值给寄存器v0；</li>
<li>把字符串常量 “hello, lambda” 赋值给寄存器v1；</li>
<li>调用android.util.Log的静态方法d，把寄存器v0和v1的值传了进去（Log.d(“Application”, “hello, lambda”);）；</li>
<li>创建java.lang.RuntimeException对象实例，并赋值到寄存器v0上；</li>
<li>调用java.lang.RuntimeException的<init>()方法（即无参构造函数），目标对象是寄存器v0储存的值；</init></li>
<li>抛出异常，目标对象是寄存器v0储存的值（throw new RuntimeException();）；  </li>
</ol>
<p><strong>这里和Java的处理方式是一样的</strong>，将Lambda主体移到了一个额外生成的方法里。<br>查看onCreate()方法：</p>
<pre><code>    method protected onCreate(Landroid/os/Bundle;)V
        .registers 3
        .param p1, &quot;savedInstanceState&quot;    # Landroid/os/Bundle;
    
        .line 12
        invoke-super &#123;p0, p1&#125;, Landroidx/appcompat/app/AppCompatActivity;-&gt;onCreate(Landroid/os/Bundle;)V
    
        .line 13
        const v0, 0x7f0b001c
    
        invoke-virtual &#123;p0, v0&#125;, Lcom/hxs/androiddesugardemo/MainActivity;-&gt;setContentView(I)V
    
        .line 14
        sget-object v0, Lcom/hxs/androiddesugardemo/-$$Lambda$MainActivity$NKcUHI3kbmdlSYn5oJ5mHUINomA;-&gt;INSTANCE:Lcom/hxs/androiddesugardemo/-$$Lambda$MainActivity$NKcUHI3kbmdlSYn5oJ5mHUINomA;
    
        .line 18
        .local v0, &quot;r&quot;:Ljava/lang/Runnable;
        invoke-interface &#123;v0&#125;, Ljava/lang/Runnable;-&gt;run()V
    
        .line 19
        return-void
    .end method
</code></pre>
<p>​<br>第14行，获取那个自动生成的实现类的静态变量==INSTANCE==，它的类型是这个类本身，也就是说INSTANCE是自动生成的实现类的实例，并赋值到寄存器v0上；<br>第18行，声明局部变量<strong>r</strong>，类型是java/lang/Runnable，初始值是寄存器**v0的值，然后调用java/lang/Runnable的借口方法run()，目标对象是寄存器v0存储的值。  </p>
<p> <strong>这里把原来的【创建对象实例】改成了【获取静态字段】。其实这只是一个优化，因为lambda函数体没有依赖CallerClass的变量或方法，完全可以作为一个静态变量存在，这样能避免反复创建对象</strong></p>
<p>查看这个实现类的字节码：</p>
<pre><code>    .class public final synthetic Lcom/hxs/androiddesugardemo/-$$Lambda$MainActivity$NKcUHI3kbmdlSYn5oJ5mHUINomA;
    .super Ljava/lang/Object;
    .source &quot;lambda&quot;
    
    # interfaces
    .implements Ljava/lang/Runnable;
</code></pre>
<p>​<br>        # static fields<br>        .field public static final synthetic INSTANCE:Lcom/hxs/androiddesugardemo/-$$Lambda$MainActivity$NKcUHI3kbmdlSYn5oJ5mHUINomA;</p>
<p>​<br>        # direct methods<br>        .method static synthetic constructor <clinit>()V<br>            .registers 1</clinit></p>
<pre><code>        new-instance v0, Lcom/hxs/androiddesugardemo/-$$Lambda$MainActivity$NKcUHI3kbmdlSYn5oJ5mHUINomA;
    
        invoke-direct &#123;v0&#125;, Lcom/hxs/androiddesugardemo/-$$Lambda$MainActivity$NKcUHI3kbmdlSYn5oJ5mHUINomA;-&gt;&lt;init&gt;()V
    
        sput-object v0, Lcom/hxs/androiddesugardemo/-$$Lambda$MainActivity$NKcUHI3kbmdlSYn5oJ5mHUINomA;-&gt;INSTANCE:Lcom/hxs/androiddesugardemo/-$$Lambda$MainActivity$NKcUHI3kbmdlSYn5oJ5mHUINomA;
    
        return-void
    .end method
    
    .method private synthetic constructor &lt;init&gt;()V
        .registers 1
    
        invoke-direct &#123;p0&#125;, Ljava/lang/Object;-&gt;&lt;init&gt;()V
    
        return-void
    .end method
    
    # virtual methods
    .method public final run()V
        .registers 1
    
        invoke-static &#123;&#125;, Lcom/hxs/androiddesugardemo/MainActivity;-&gt;lambda$onCreate$0()V
    
        return-void
    .end method
</code></pre>
<p>在类被加载的时候，就创建了他自己的对象实例并赋值给静态变量<strong>INSTANCE</strong>。实现的run()方法，里面也是直接调用MainActivity的<strong>静态方法lambda$onCreate$0</strong>。  </p>
<p><strong>如果Lambda表达式调用了CallerClass的变量呢？</strong><br>将代码稍微改造下：</p>
<pre><code>public class MainActivity extends AppCompatActivity &#123;

    @Override
    protected void onCreate(Bundle savedInstanceState) &#123;
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        String tip = &quot;hello lambda&quot;;
        Runnable r = () -&gt; &#123;
            Log.d(&quot;MainActivity&quot;, tip);
            throw new RuntimeException();
        &#125;;
        r.run();
    &#125;
&#125;
</code></pre>
<p>查看**onCreate()**方法的字节码：</p>
<pre><code>.method protected onCreate(Landroid/os/Bundle;)V
    .registers 4
    .param p1, &quot;savedInstanceState&quot;    # Landroid/os/Bundle;

    .line 12
    invoke-super &#123;p0, p1&#125;, Landroidx/appcompat/app/AppCompatActivity;-&gt;onCreate(Landroid/os/Bundle;)V

    .line 13
    const v0, 0x7f0b001c

    invoke-virtual &#123;p0, v0&#125;, Lcom/hxs/androiddesugardemo/MainActivity;-&gt;setContentView(I)V

    .line 14
    const-string v0, &quot;hello lambda&quot;

    .line 15
    .local v0, &quot;tip&quot;:Ljava/lang/String;
    new-instance v1, Lcom/hxs/androiddesugardemo/-$$Lambda$MainActivity$f0md4yi5o91GRldVVHmjjcHcul8;

    .local v1, &quot;r&quot;:Ljava/lang/Runnable;
    invoke-direct &#123;v1, v0&#125;, Lcom/hxs/androiddesugardemo/-$$Lambda$MainActivity$f0md4yi5o91GRldVVHmjjcHcul8;-&gt;&lt;init&gt;(Ljava/lang/String;)V

    .line 19
    invoke-interface &#123;v1&#125;, Ljava/lang/Runnable;-&gt;run()V

    .line 20
    return-void
.end method  
</code></pre>
<p>第15行，对比之前获取静态变量INSTANCE，<strong>这里变成了new-instace构造这个实现类的实例</strong><br>查看该实现类的字节码： </p>
<pre><code>    .class public final synthetic Lcom/hxs/androiddesugardemo/-$$Lambda$MainActivity$f0md4yi5o91GRldVVHmjjcHcul8;
    .super Ljava/lang/Object;
    .source &quot;lambda&quot;
    
    # interfaces
    .implements Ljava/lang/Runnable;
</code></pre>
<p>​<br>        # instance fields<br>        .field public final synthetic f$0:Ljava/lang/String;</p>
<p>​<br>        # direct methods<br>        .method public synthetic constructor <init>(Ljava/lang/String;)V<br>            .registers 2</init></p>
<pre><code>        invoke-direct &#123;p0&#125;, Ljava/lang/Object;-&gt;&lt;init&gt;()V
    
        iput-object p1, p0, Lcom/hxs/androiddesugardemo/-$$Lambda$MainActivity$f0md4yi5o91GRldVVHmjjcHcul8;-&gt;f$0:Ljava/lang/String;
    
        return-void
    .end method
</code></pre>
<p>​<br>        # virtual methods<br>        .method public final run()V<br>            .registers 2</p>
<pre><code>        iget-object v0, p0, Lcom/hxs/androiddesugardemo/-$$Lambda$MainActivity$f0md4yi5o91GRldVVHmjjcHcul8;-&gt;f$0:Ljava/lang/String;
    
        invoke-static &#123;v0&#125;, Lcom/hxs/androiddesugardemo/MainActivity;-&gt;lambda$onCreate$0(Ljava/lang/String;)V
    
        return-void
    .end method
</code></pre>
<p>已经没有加载时构建实例对象的代码了，不过实现的run()方法还是一致的。  </p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p><strong>Andorid的Lambda在打包成dex时会直接生成对应的实现类，相比于java的<code>invokedynamic</code>这种方式，不同的只是==生成实现类的时机==，这跟直接使用匿名内部类的效基本没有区别。</strong>  </p>
<p>其实在Lambda编译成class时，还是按照Java原本的方式（<code>invokedynamic</code>）处理的，查看class文件：</p>
<pre><code>    public class com.hxs.androiddesugardemo.MainActivity extends androidx.appcompat.app.AppCompatActivity &#123;
      public com.hxs.androiddesugardemo.MainActivity();
        Code:
           0: aload_0
           1: invokespecial #1                  // Method androidx/appcompat/app/AppCompatActivity.&quot;&lt;init&gt;&quot;:()V
           4: return
    
      protected void onCreate(android.os.Bundle);
        Code:
           0: aload_0
           1: aload_1
           2: invokespecial #2                  // Method androidx/appcompat/app/AppCompatActivity.onCreate:(Landroid/os/Bundle;)V
           5: aload_0
           6: ldc           #4                  // int 2131427356
           8: invokevirtual #5                  // Method setContentView:(I)V
          11: ldc           #6                  // String hello lambda
          13: astore_2
          14: aload_2
          15: invokedynamic #7,  0              // InvokeDynamic #0:run:(Ljava/lang/String;)Ljava/lang/Runnable;
          20: astore_3
          21: aload_3
          22: invokeinterface #8,  1            // InterfaceMethod java/lang/Runnable.run:()V
          27: return
    &#125;
</code></pre>
<p>脱糖这一步是由D8编译器去做的，<strong>desugarDebug(Release)FileDependencies</strong>和**dexBuilderDebug(Release)**，前者是把项目依赖的所有jar包脱糖，后者是将项目自己的class脱糖。</p>
<h3 id="D8脱糖"><a href="#D8脱糖" class="headerlink" title="D8脱糖"></a>D8脱糖</h3><p>使用Javac将Java8.java编译成.class</p>
<pre><code>class Java8 &#123;
    interface Logger &#123;
        void log(String s);
    &#125;

    public static void main(String... args) &#123;
        sayHi(s -&gt; System.out.println(s));
    &#125;

    private static void sayHi(Logger logger) &#123;
        logger.log(&quot;Hello!&quot;);
    &#125;
&#125;
</code></pre>
<p>​<br>在使用 javac 编译之后，使用 dx 直接运行会报错：</p>
<pre><code>MiracledeMacBook-Pro:d8 miracle$ ~/Library/Android/sdk/build-tools/28.0.3/dx --dex --output . *.class
Uncaught translation error: com.android.dx.cf.code.SimException:
ERROR in Java8.main:([Ljava/lang/String;)V: 
invalid opcode ba - invokedynamic requires --min-sdk-version &gt;= 26 (currently 13)
</code></pre>
<p>因为 lambda 的实现使用到了 Java 7 新增加的字节码 invokedynamic. 正如报错信息提示的那样，<strong>Android 对这个字节码的支持是在 API 26(8.0) 以上才实现的</strong>。因此android有一个名为desugaring的编译流程，它将lambda转换为所有API都兼容的形式。  </p>
<h4 id="desugaring的目标？"><a href="#desugaring的目标？" class="headerlink" title="desugaring的目标？"></a>desugaring的目标？</h4><p>让新的语法糖可以运行在所有设备上      </p>
<h4 id="desugaring的历史"><a href="#desugaring的历史" class="headerlink" title="desugaring的历史"></a>desugaring的历史</h4><p>我们使用一款名为 Retrolambda 来实现相关的功能。它使用 JVM 的内建机制，在运行时而不是编译时将 lambda 转换为类的实现。生成新的类很容易增加方法数，但是如果权衡利弊这些成本还是可以接受的 (but work on the tool over time reduced the cost to something reasonable).</p>
<p>随后 Android 的工具链团队发布了一款新的编译器，称其可以将 Java 8 的语法糖脱糖的同时还兼备更好的性能。这款编译器是基于 Eclipse 的 Java 编译器开发的，但是目标是 Dalvik 字节码而不是 Java 字节码。这个版本的 Java 8 的脱糖实现代价高昂，并且使用率低、性能差，与其他工具链不兼容。</p>
<p>当上述的新的编译器最终被弃用时（感谢），一款新的将 Java 字节码翻译到 Java 字节码的脱糖转换器被集成到了 Android Gradle Plugin 中，它实际上源自 Google 自己的构建工具 Bazel. 其脱糖过程挺高效的，但是性能表现仍然不是很理想。事实上它是一个渐进式的解决方案，不停地在寻找更好的解决方案。</p>
<p>随后 D8 发布了，被用来取代传统的 dx 工具链，承诺在 dex 过程中脱糖而不是使用标准的 Java 字节码做转换。相对于 dx 而言，D8 在性能上取得了巨大的成功，并且带来了更高效的脱糖字节码。从 Android Gradle Plugin 3.1 版本开始，D8 成为了默认的 dex 工具，在 3.2 版本开始负责脱糖。</p>
<p>然后使用D8将上述例子编译为.dex： </p>
<pre><code>java -jar d8.jar --lib /Users/miracle/Library/Android/sdk/platforms/android-28/android.jar
--release 
--output . *.class
</code></pre>
<p>发现编译成功了：</p>
<pre><code>Java8$Logger.class    
Java8.java
Java8.class
classes.dex
</code></pre>
<p>然后使用Android SDK 中提供的 dexdump 来查看classes.dex中的字节码:  <code>/Users/miracle/Library/Android/sdk/build-tools/28.0.3/dexdump -d classes.dex：</code>（分析流程同上）</p>
<blockquote>
<p><strong>SYNTHETIC</strong> 标志相关类和方法是被生成的<br><strong>lambda 代码块存在于原来的类的内部的原因在于，它可能需要访问该类的私有成员变量，而生成的类却是访问不到的。</strong>. </p>
</blockquote>
<h3 id="原生的Lambda"><a href="#原生的Lambda" class="headerlink" title="原生的Lambda"></a>原生的Lambda</h3><p>当配合 –min-api 26 参数编译的话，它会假定你将使用原生的lambda实现而不会进行脱糖：  </p>
<pre><code>java -jar d8.jar --lib /Users/miracle/Library/Android/sdk/platforms/android-28/android.jar
    --release 
    --min-api 26
    --output . *.class
</code></pre>
<p>然而查看生成的.dex文件，还是会发现-$$Lambda$Java8$QkyWJ8jlAksLjYziID4cZLvHwoY 的类被生成了。是bug吗？<br>原因是java原生的指令invokedynamic的处理是借助java.lang.invoke.LambdaMetafactory 这个类中的名为 metafactory 的方法在运行时即时创建lambda相关的匿名类。而在android的运行时库中（android.jar）其实并没有这个类，android实现了与invokedynamic相同效果的字节码支持，但jdk内建的LambdaMetafactory并不可用。所以D8将这个匿名类的生成放到了编译期，然后使用<code>invokedynamic</code>和<code>invoke-custom</code>这两条指令去执行。<br><a target="_blank" rel="noopener" href="https://www.pnfsoftware.com/blog/android-o-and-dex-version-38-new-dalvik-opcodes-to-support-dynamic-invocation/">这篇文章</a>对这两条指令做了解释，不太懂，大概意思是google为了支持更多的动态语言特性？  </p>
<h3 id="Method-Referencens-方法引用"><a href="#Method-Referencens-方法引用" class="headerlink" title="Method Referencens(方法引用)"></a>Method Referencens(方法引用)</h3><p>Java8中另一个语法糖，作为lambda的补充，使得创建lambda去指向一个已有的方法的操作变得高效。</p>
<pre><code>public static void main(String... args) &#123;
-    sayHi(s -&gt; System.out.println(s));
+    sayHi(System.out::println);
&#125;
</code></pre>
<p>使用 javac 编译后，再用 D8 处理，我们会发现与之前的 lambda 有一处显著的不同，会发现生成的 lambda 类的代码块被改变了：  </p>
<pre><code>|[00023c] -..Lambda.teOjDu261Kz9uXGt1wlPvIP5S04.log:(Ljava/lang/String;)V
|0000: iget-object v0, v0, L-$$Lambda$teOjDu261Kz9uXGt1wlPvIP5S04;.f$0:Ljava/io/PrintStream; // field@0000
|0002: invoke-virtual &#123;v0, v1&#125;, Ljava/io/PrintStream;.println:(Ljava/lang/String;)V // method@0006
|0005: return-void
</code></pre>
<p>与之前调用生成的Java8.lambda$main$0类中包含System.out.print()方法不同，log的实现直接调用了System.out.print()  </p>
<p>生成的 lambda 类不再是静态单例。字节序 0000 直接读取了 PrintStream 的实例引用，该引用即是 System.out, 它在 main 方法中被调用，并且被传递给相应的构造器（名为 <init> 的字节码）  </init></p>
<p> 将其进行源码级别的转换：</p>
<pre><code>public static void main(String... args) &#123;
-    sayHi(System.out::println);
+    sayHi(new -$$Lambda$1Osqr2Z9OSwjseX_0FMQJcCG_uM(System.out));
   &#125;
@@
 &#125;
+
+class -$$Lambda$1Osqr2Z9OSwjseX_0FMQJcCG_uM implements Java8.Logger &#123;
+  private final PrintStream ps;
+
+  -$$Lambda$1Osqr2Z9OSwjseX_0FMQJcCG_uM(PrintStream ps) &#123;
+    this.ps = ps;
+  &#125;
+
+  @Override public void log(String s) &#123;
+    ps.println(s);
+  &#125;
+&#125;
</code></pre>
<h3 id="Interface-Methods"><a href="#Interface-Methods" class="headerlink" title="Interface Methods"></a>Interface Methods</h3><p>Java 8 另一个显著的特性是可以在接口中定义静态方法和默认方法。接口中的静态方法可以被用来提供相关的工厂方法，或者其他有助于操作接口的方法。接口中的默认方法则允许你给已有接口中添加默认的方法实现，同时保持兼容性（你不需要给所有实现了该接口的类再全部实现一个新的方法） </p>
<p> <strong>这两种语法糖在 API 24 以上都是使用的原生实现。因此不像 lambda 和方法引用，–min-api 24 不会触发 D8 的脱糖操作</strong>  </p>
<p><a target="_blank" rel="noopener" href="https://jakewharton.com/androids-java-8-support/">Android’s Java 8 Support</a> - Jake Wharton. </p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Lambda/" rel="tag"># Lambda</a>
              <a href="/tags/JVM/" rel="tag"># JVM</a>
              <a href="/tags/Android/" rel="tag"># Android</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2021/03/02/AndroidStudio%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89/" rel="next" title="AndroidStudio插件开发（一）">
      AndroidStudio插件开发（一） <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E7%B3%96"><span class="nav-number">1.</span> <span class="nav-text">语法糖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E8%AF%AD%E6%B3%95%E7%B3%96%EF%BC%88%E8%84%B1%E7%B3%96%EF%BC%89"><span class="nav-number">2.</span> <span class="nav-text">解语法糖（脱糖）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E8%BD%AC%E5%86%99%E6%88%90Lambda%EF%BC%8C%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8A%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.</span> <span class="nav-text">Java匿名内部类和转写成Lambda，字节码上的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E4%B8%AD%E7%9A%84Lambda%E4%B8%8EAndroid%E4%B8%AD%E7%9A%84Lambda%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="nav-number">4.</span> <span class="nav-text">Java中的Lambda与Android中的Lambda有什么不同？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA"><span class="nav-number">4.1.</span> <span class="nav-text">结论</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#D8%E8%84%B1%E7%B3%96"><span class="nav-number">5.</span> <span class="nav-text">D8脱糖</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#desugaring%E7%9A%84%E7%9B%AE%E6%A0%87%EF%BC%9F"><span class="nav-number">5.1.</span> <span class="nav-text">desugaring的目标？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#desugaring%E7%9A%84%E5%8E%86%E5%8F%B2"><span class="nav-number">5.2.</span> <span class="nav-text">desugaring的历史</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%94%9F%E7%9A%84Lambda"><span class="nav-number">6.</span> <span class="nav-text">原生的Lambda</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Method-Referencens-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="nav-number">7.</span> <span class="nav-text">Method Referencens(方法引用)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Interface-Methods"><span class="nav-number">8.</span> <span class="nav-text">Interface Methods</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="huangxiushuo"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">huangxiushuo</p>
  <div class="site-description" itemprop="description">上海</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/huangxshuo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;huangxshuo" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:huangxiushuo@gmail.com" title="E-Mail → mailto:huangxiushuo@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">huangxiushuo</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://huangxiushuo.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "https://huangxshuo.github.io/2021/01/29/%E8%AF%AD%E6%B3%95%E7%B3%96%E3%80%81%E8%84%B1%E7%B3%96%E3%80%81D8/";
    this.page.identifier = "2021/01/29/语法糖、脱糖、D8/";
    this.page.title = "语法糖、脱糖、D8";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://huangxiushuo.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
